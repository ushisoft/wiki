## 分布式锁解决方案

## 分布式锁条件

### 基本条件

同多线程（堆中的成员变量）和多进程（共享内存中的数据或磁盘中的文件）环境下的锁，可以发现锁的实现有很多共通之处，它们都需要满足一些最基本的条件：

- 需要有存储锁的空间，并且锁的空间是可以访问到的。
- 锁需要被唯一标识。
- 锁要有至少两种状态。

#### 存储空间

最普遍的外部存储空间就是数据库了，事实上也确实有基于数据库做分布式锁（行锁、version乐观锁），如quartz集群架构中就有所使用。

除此以外，还有各式缓存如Redis、Tair、Memcached、MongoDB，当然还有专门的分布式协调服务Zookeeper，甚至是另一台主机。只要可以存储数据、锁在其中可以被多主机访问到，那就可以作为分布式锁的存储空间。

#### 唯一标识

在多线程环境中，锁可以是一个对象，那么对这个对象的引用便是这个唯一标识。

多进程环境中，信号量在共享内存中也是由引用来作为唯一的标识。

但是如果不在内存中，失去了对锁的引用，如何唯一标识它呢？上文提到的有名信号量，便是用硬盘中的文件名作为唯一标识。

因此，在分布式环境中，只要给这个锁设定一个名称，并且保证这个名称是全局唯一的，那么就可以作为唯一标识。

#### 至少两种状态

为了给临界区加锁和解锁，需要存储两种不同的状态。

如ReentrantLock中的status，0表示没有线程竞争，大于0表示有线程竞争；信号量大于0表示可以进入临界区，小于等于0则表示需要被阻塞。

因此只要在分布式环境中，锁的状态有两种或以上：如有锁、没锁；存在、不存在等，均可以实现。

#### 问题

1. 锁状态判断原子性无法保证
   从读取锁的状态，到判断该状态是否为被锁，需要经历两步操作。如果不能保证这两步的原子性，就可能导致不止一个请求获取到了锁，这显然是不行的。

   因此，我们需要保证锁状态判断的原子性。

2. 网络断开或主机宕机，锁状态无法清除
   假设在主机已经获取到锁的情况下，突然出现了网络断开或者主机宕机，如果不做任何处理该锁将仍然处于被锁定的状态。那么之后所有的请求都无法再成功抢占到这个锁。

   因此，我们需要在持有锁的主机宕机或者网络断开的时候，及时的释放掉这把锁。

3. 无法保证释放的是自己上锁的那把锁
   在解决了问题2的情况下再设想一下，假设持有锁的主机A在临界区遇到网络抖动导致网络断开，分布式锁及时的释放掉了这把锁。之后，另一个主机B占有了这把锁，但是此时主机A网络恢复，退出临界区时解锁。由于都是同一把锁，所以A就会将B的锁解开。此时如果有第三个主机尝试抢占这把锁，也将会成功获得。

   因此，我们需要在解锁时，确定自己解的这个锁正是自己锁上的。

### 进阶条件

有时间再研究。

- 可重入


- 惊群效应


- 公平锁和非公平锁


- 阻塞锁和自旋锁

### 典型实现

#### ZooKeeper

一个典型的例子：[Menagerie](https://github.com/sfines/menagerie)

使用ZK临时节点，可以直接避免网络断开或主机宕机，锁状态无法清除的问题。

#### Redis

Redis有SETNX（即SET if Not Exists）和GETSET（先写新值，返回旧值，原子性操作，可以用于分辨是不是首次操作）操作。

为了防止主机宕机或网络断开之后的死锁，Redis没有ZK那种天然的实现方式，只能依赖设置超时时间来规避。

[Redisson](https://github.com/redisson/redisson)是一个官方推荐的Redis客户端并且实现了很多分布式的功能，它的分布式锁提供了一种完善的解决方案。